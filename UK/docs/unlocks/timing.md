# Таймінг
Якщо ви справді хочете оптимізувати свої методи, вам потрібно розуміти, як вимірюється час у цій грі. Це розблокування присвячене саме цьому.

## Нові функції
Існує дві корисні функції для вимірювання того, скільки часу займають події:

`get_time()` повертає час у секундах з початку гри.

`get_tick_count()` повертає кількість тіків, виконаних з початку виконання.

Ці дві функції, а також `quick_print()`, є повністю безкоштовними. Навіть операція виклику для них є безкоштовною.

## Деталі Runtime (Час виконання)

### До відома
Це не те, як продуктивність працює в реальному світі. Це просто правила, вигадані для цієї гри, щоб мати послідовну та зрозумілу модель таймінгу.
Ймовірно, вам це знадобиться, лише якщо ви хочете гіпер-оптимізувати свій код.


Базова одиниця часу для виконання коду називається "тік". Без покращень швидкості та енергії виконання відбувається зі швидкістю `400` тіків на секунду.

Загалом, операції, які об'єднують два значення, такі як `+, -, *, /, //, %, and, or, ...`, займають один тік для виконання.
Унарний мінус `-` (для одного значення) та `not` є безкоштовними.
Розгалуження `if` також займає один тік (на додаток до часу, необхідного для оцінки умови виразу).
Виклики функцій та читання і запис змінних є безкоштовними, але визначення функцій займають 1 тік.
Statements `import` є безкоштовними.
Доступ до імпортованого модуля за допомогою оператора `.` є безкоштовним.
Якщо функцію або модуль було передано через аргументи або присвоєння змінних, їх використання коштуватиме 1 тік замість 0.
Цикли `for` та `while` займають один тік для початку, але ітерації є безкоштовними (не враховуючи час на оцінку умови/послідовності виразів).
`return`, `break` та `continue` є безкоштовними.
`pass` займає один тік, тому його можна використовувати для створення точних затримок.
Індексування структури даних займає один тік для оператора індексу, а у випадку словника або множини — додаткові тіки залежно від розміру ключа.

Кількість тіків, яку займають вбудовані функції, задокументована в документації кожної функції окремо.
