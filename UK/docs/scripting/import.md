# Імпорт
Якщо розмістити весь код в одному файлі, він швидко стане некерованим. 
Оператори `import` дозволяють імпортувати функції та глобальні змінні з іншого файлу.
Як це працює на одному скріншоті:
![](ImportsInOnePicture400)

Тут `import module2` запускає файл з назвою `module2` і надає вам доступ до всіх його глобальних змінних.
Потім ви можете отримати доступ до змінних і функцій в імпортованому модулі за допомогою оператора `.`.
Отже, у цьому прикладі `module2.print_x()` викликає `print_x()` у `module2`.

### Не потрібно читати далі

Ви також можете перемістити глобальні змінні з імпортованого модуля в поточну область дії, де виконується оператор import, використовуючи синтаксис `from`.

`from module2 import print_x
print_x()`
Імпортує тільки вказані глобальні змінні з `module2`.

або

`from module2 import *
print_x()`
Імпортує всі глобальні змінні з `module2`.

Це також імпортує файл `module2`, але замість доступу до нього через змінну з іменем `module2`, воно розпаковує глобальні змінні з `module2` і присвоює їх безпосередньо в локальній області дії.

Ця форма імпорту зазвичай не рекомендується, оскільки вона не працює належним чином, коли два файли імпортують один одного, і ви можете випадково перезаписати змінні в імпортованому файлі через конфлікт імен. Якщо ви не знаєте, що робите, безпечніше уникати синтаксису `from`.

# Як це насправді працює

## TLDR
Імпорт може бути досить неінтуїтивним, але більшості проблем можна уникнути, дотримуючись синтаксису `import file` замість `from file import` і обгортаючи все, що не є глобальним визначенням, в
`if __name__ == «__main__»:`

## Побічні ефекти імпорту
При першому імпорті файлу він буде виконаний повністю, після чого ви отримаєте доступ до всіх змінних, які були визначені під час виконання.
Якщо ви імпортуєте той самий файл знову, він просто поверне кешований модуль з першого разу.

Це означає, що оператори імпорту можуть мати побічні ефекти. Якщо ви імпортуєте файл, який викликає `harvest()`, він фактично виконає збір під час імпорту. Але коли ви імпортуєте його знову, він не виконає збір ще раз, оскільки файл виконується тільки один раз.

Існує спосіб уникнути таких побічних ефектів за допомогою змінної `__name__`. Ця змінна автоматично встановлюється на `«__main__»`, коли файл запускається безпосередньо, і на ім'я файлу, коли файл запускається через `import`.
Вважається доброю практикою розміщувати будь-який код, який ви не хочете запускати під час імпорту файлу, всередині блоку `if __name__ == «__main__»:`.

Загальна структура файлів у Python полягає в тому, щоб розмістити код, який повинен виконуватися під час запуску файлу, у функції `main()`. Таким чином ви отримуєте чітке розмежування між локальними змінними (визначеними всередині `main()`) та глобальними змінними, які можна імпортувати (визначеними поза `main()`).

`a_global_variable = "global"

def main():
    a_local_variable = "local"
    # do things

if __name__ == "__main__":
    main()`

## Цикли імпорту
Що відбувається, якщо файл `a` імпортує файл `b`, а файл `b` імпортує файл `a`?

файл `a`:
`import b
x = 0`

файл `b`:
`import a
def f():
    print(a.x)`

Це буде працювати нормально. Припустимо, що жоден з двох файлів ще не завантажений, і хтось інший виконує `import a`.

-`a` виконується до рядка `import b`.
-`b` виконується до рядка `import a`.
-Модуль `a` вже існує, але не містить `x`, оскільки він досяг лише рядка `import b`.
-`b` зберігає посилання на наполовину завантажений модуль `a` у змінній під назвою `a`.
-`b` виконує оператор `def` і зберігає функцію `f()`.
-`a` продовжує виконуватися і ініціалізує `x`.

Коли хтось викликає `b.f()`, він правильно виведе `0`, оскільки модуль `a`, на який посилається `b`, тепер повністю завантажений.

Тепер розглянемо той самий код із використанням синтаксису `from`.

файл `a`:
`from b import *
x = 0`

файл `b`:
`from a import *
def f():
    print(x)`

-`a` виконується до рядка `from b import *`.
-`b` виконується до рядка `from a import *`.
-Модуль `a` вже існує, але ще не був повністю виконаний.
-`b` розпаковує все, що наразі знаходиться в `a`, у свою власну глобальну область. На цьому етапі `a` не містить нічого, оскільки ще не дійшов до рядка `x = 0`, тому нічого не імпортується.
-`b` виконує оператор `def` і зберігає функцію `f()`.
-`a` продовжує виконуватися і ініціалізує `x`.

Якщо хтось зараз викличе `b.f()`, він отримає помилку, що `x` не існує в поточній області видимості. Це тому, що цього разу `b` не має посилання на `a`, яке все ще завантажується, і не бачить визначень, які були додані після імпорту.