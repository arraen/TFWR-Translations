@error_missing_default_parameter = 모든 기본 인수는 인수 목록의 끝에 있어야 합니다.
@error_invalid_name = {0}의 이름이 유효하지 않습니다. 이름은 문자로 시작해야 하며, 문자와 숫자, 밑줄만 포함할 수 있습니다. 또한 예약된 키워드일 수 없습니다.
@error_reserved_keyword = {0}: 예약된 키워드이기 때문에 이름으로 사용할 수 없습니다.
@error_invalid_assign_expr = 이 표현식에는 값을 할당할 수 없습니다.
@error_no_statements = 코드 블록은 적어도 하나의 문장을 포함해야 합니다. 
문장은 `harvest()` 같은 함수 호출이나 변수 할당이 될 수 있습니다. 
코드 블록에서 아무것도 하지 않으려면 `pass` 문장을 사용하세요.
@error_not_enough_indentation = 여기에 들여쓰기가 충분하지 않습니다. 
새 코드 블록을 구분하려면 : 뒤에 이전보다 더 많은 들여쓰기가 있어야 합니다. 
Tab 키를 사용하여 코드를 들여쓰세요.
@error_too_much_indentation = 여기에 들여쓰기가 너무 많습니다.
코드 블록 내의 모든 문장은 들여쓰기가 같아야 합니다.
@error_not_a_statement = 유효한 문장이 아닙니다. 
@error_not_a_statement2 = 유효한 문장이 아닙니다. 혹시 {0}을(를) 쓰려고 하셨나요?
@error_invalid_expression = 유효한 표현식이 아닙니다.
@error_new_line_expected = 여기에 새 줄이 필요합니다.
@error_unexpected_token = 여기에 {0}이(가) 필요합니다.
@error_missing_colon = 모든 코드 블록의 시작에는 콜론 `:`이 있어야 합니다.
@error_unexpected_assign = 여기에는 할당할 수 없습니다. 동등성을 확인하려면 대신 `==`를 사용하세요.
@error_invalid_for_syntax = 이것은 유효한 for 루프가 아닙니다. for 루프는 다음과 같습니다.
`for n in range(3):`
`for` 다음에는 항상 루프 변수, `in`, 시퀀스가 옵니다. 이 예시에서 `n`은 변수 이름이지만 다른 이름으로 바꿀 수 있습니다.
@error_unknown_method = 이 메서드는 존재하지 않습니다.
@error_bad_backslash = 백슬래시는 표현식을 여러 줄로 나눌 때 사용할 수 있습니다. 하지만 그 뒤에 줄 바꿈을 추가해야 합니다.
@error_mixed_indentation = 탭과 공백을 섞어 쓰면 안 됩니다.
@error_expected_close_token = 쉼표 또는 닫는 괄호가 필요합니다.
@error_wrong_dict_literal = 딕셔너리의 키와 값을 구분하는 :이 필요합니다.
@error_assign_before_global = {0}이(가) 전역 선언 전에 할당되었습니다.
@error_wildcard_imports_not_allowed_in_function = `from x import *` 형태의 import는 함수 내에서 허용되지 않습니다.
@error_invalid_import = 유효한 식별자가 아닌 이름의 파일은 가져올 수 없습니다. 유효한 식별자는 문자, 숫자, 밑줄만 포함할 수 있습니다. 파일 이름에 다른 문자가 포함된 경우 이름을 바꿔야 합니다.
@error_invalid_number_format = 유효한 숫자 형식이 아닙니다.
@error_compared_item_with_number = {0}은(는) 숫자가 아니라 아이템이에요. 숫자와 비교하는 것은 의미가 없어요.

해당 아이템을 얼마나 가지고 있는지 확인하고 싶다면, 대신 `num_items(`{0}`)`를 사용하세요.
@error_compared_entity_with_number = {0}은(는) 숫자가 아니라 엔티티예요. 숫자와 비교하는 것은 의미가 없어요.
@error_compared_unlock_with_number = {0}은(는) 숫자가 아니라 해금 요소예요. 숫자와 비교하는 것은 의미가 없어요.

몇 번이나 해금했는지 확인하고 싶다면, 대신 `num_unlocked(`{0}`)`를 사용하세요.
@error_nonsensical_or = 조건문에서 `or `{0}를 사용하는 것은 {0}이(가) 상수이기 때문에 의미가 없어요. 
`or`보다 비교 연산자가 먼저 평가된다는 점에 유의하세요.

예시:
`x == 5 or 6` 
은 다음과 같아요 
`(x == 5) or 6`
0이 아닌 숫자는 true로 간주되므로, 이것은 다음과 같아요 
`(x == 5) or True`
이것은 항상 true가 돼요.

이론적으로는 유효한 Python 코드이지만, 이런 식으로 코드를 작성할 이유는 전혀 없어요.
@error_item_condition = {0}은(는) 아이템이며 불리언이 아니에요. 그 자체를 조건으로 사용하는 것은 의미가 없어요. 
혹시 어떤 값이 그 아이템과 같은지 확인하고 싶었나요?
`some_variable == `{0}
@error_unlock_condition = {0}은(는) 해금 요소이며 불리언이 아니에요. 그 자체를 조건으로 사용하는 것은 의미가 없어요. 
해금 요소가 해금되었는지는 이렇게 확인할 수 있어요:
`num_unlocked(`{0}`) > 0`
@error_entity_condition = {0}은(는) 엔티티이며 불리언이 아니에요. 그 자체를 조건으로 사용하는 것은 의미가 없어요.
드론 아래에 있는 엔티티의 종류는 이렇게 확인할 수 있어요:
`get_entity_type() == `{0}
@error_ground_condition = {0}은(는) 땅의 종류이며 불리언이 아니에요. 그 자체를 조건으로 사용하는 것은 의미가 없어요.
드론 아래에 있는 땅의 종류는 이렇게 확인할 수 있어요:
`get_ground_type() == `{0}