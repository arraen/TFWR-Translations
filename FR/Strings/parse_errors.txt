@error_missing_default_parameter = Tous les arguments par défaut doivent se trouver à la fin de la liste d'arguments.
@error_invalid_name = {0} n'est pas un nom valide. Les noms doivent commencer par une lettre et ne peuvent contenir que des lettres, des chiffres et des tirets bas. Il ne peut pas non plus être un mot-clé réservé.
@error_reserved_keyword = {0} est un mot-clé réservé. Tu ne peux pas l'utiliser comme nom.
@error_invalid_assign_expr = Impossible d'assigner une valeur à cette expression.
@error_no_statements = Un bloc de code doit contenir au moins une instruction. 
Une instruction peut être un appel de fonction comme `harvest()` ou une affectation de variable. 
Si tu ne souhaites rien faire dans le bloc de code, utilise une instruction `pass`.
@error_not_enough_indentation = Il n'y a pas assez d'indentation ici. 
Il doit y avoir plus d'indentation après un : qu'avant pour séparer le nouveau bloc de code. 
Utilise la touche Tab pour indenter le code.
@error_too_much_indentation = Il y a trop d'indentation ici. 
L'indentation doit être la même pour toutes les instructions d'un même bloc de code.
@error_not_a_statement = Ceci n'est pas une instruction valide. 
@error_not_a_statement2 = Ceci n'est pas une instruction valide. Voulais-tu écrire {0} ?
@error_invalid_expression = Ceci n'est pas une expression valide.
@error_new_line_expected = Un saut de ligne est attendu ici.
@error_unexpected_token = Un {0} est attendu ici.
@error_missing_colon = Il doit y avoir deux-points `:` au début de chaque bloc de code.
@error_unexpected_assign = Tu ne peux pas faire d'affectation ici. Pour vérifier l'égalité, utilise `==` à la place.
@error_invalid_for_syntax = Ceci n'est pas une boucle for valide. Une boucle for ressemble à ceci : 
`for n in range(3):`
Le `for` est toujours suivi de la variable de boucle, d'un `in` puis d'une séquence. Dans cet exemple, `n` est le nom de la variable, mais il peut être remplacé par n'importe quel autre nom.
@error_unknown_method = Cette méthode n'existe pas.
@error_bad_backslash = L'antislash peut être utilisé pour diviser des expressions sur plusieurs lignes. Mais tu dois ajouter un saut de ligne après.
@error_mixed_indentation = Les tabulations et les espaces ne doivent pas être mélangés.
@error_expected_close_token = Virgule ou crochet fermant attendu.
@error_wrong_dict_literal = Un : est attendu pour séparer les clés et les valeurs d'un dictionnaire.
@error_assign_before_global = {0} est assigné avant une déclaration globale.
@error_wildcard_imports_not_allowed_in_function = Les importations de la forme `from x import *` ne sont pas autorisées à l'intérieur des fonctions.
@error_invalid_import = Tu ne peux pas importer de fichiers dont les noms ne sont pas des identifiants valides. Les identifiants valides ne peuvent contenir que des lettres, des chiffres et des tirets bas. Si ton nom de fichier contient d'autres caractères, tu dois le renommer.
@error_invalid_number_format = Ce format de nombre n'est pas valide.
@error_compared_item_with_number = {0} n'est pas un nombre, c'est un objet. Le comparer à un nombre n'a pas de sens.

Si tu veux vérifier combien tu as de cet objet, utilise `num_items(`{0}`)` à la place.
@error_compared_entity_with_number = {0} n'est pas un nombre, c'est une entité. Le comparer à un nombre n'a pas de sens.
@error_compared_unlock_with_number = {0} n'est pas un nombre, c'est un déblocage. Le comparer à un nombre n'a pas de sens.

Si tu veux vérifier combien de fois tu l'as débloqué, utilise `num_unlocked(`{0}`)` à la place.
@error_nonsensical_or = Utiliser `or `{0} dans une condition n'a pas de sens car {0} est une constante. 
Note que les opérateurs de comparaison sont évalués avant `or`.

Exemple :
`x == 5 or 6` 
est équivalent à 
`(x == 5) or 6`
Les nombres non nuls sont considérés comme vrais, c'est donc équivalent à 
`(x == 5) or True`
ce qui est toujours vrai.

C'est du code Python théoriquement valide, mais il n'y a aucune raison de l'écrire de cette façon.
@error_item_condition = {0} est un objet et non un booléen. L'utiliser comme condition seule n'a pas de sens. 
Peut-être voulais-tu vérifier si une valeur est égale à cet objet ?
`some_variable == `{0}
@error_unlock_condition = {0} est un déblocage et non un booléen. L'utiliser comme condition seule n'a pas de sens. 
Voici comment tu peux vérifier si le déblocage est déverrouillé :
`num_unlocked(`{0}`) > 0`
@error_entity_condition = {0} est une entité et non un booléen. L'utiliser comme condition seule n'a pas de sens.
Voici comment tu peux vérifier le type de l'entité sous le drone :
`get_entity_type() == `{0}
@error_ground_condition = {0} est un type de sol et non un booléen. L'utiliser comme condition seule n'a pas de sens.
Voici comment tu peux vérifier le type du sol sous le drone :
`get_ground_type() == `{0}