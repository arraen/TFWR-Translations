@error_missing_default_parameter = Все аргументы по умолчанию должны быть в конце списка аргументов.
@error_invalid_name = {0} — недопустимое имя. Имя должно начинаться с буквы и может содержать только буквы, цифры и знаки подчеркивания. Оно также не может быть зарезервированным словом.
@error_reserved_keyword = {0} — зарезервированное слово. Его нельзя использовать в качестве имени.
@error_invalid_assign_expr = Невозможно присвоить значение этому выражению.
@error_no_statements = Блок кода должен содержать хотя бы одну инструкцию.
Инструкцией может быть вызов функции, например `harvest()`, или присваивание переменной.
Если ты не хочешь ничего делать в блоке кода, используй инструкцию `pass`.
@error_not_enough_indentation = Недостаточный отступ.
После знака `:` отступ увеличивают, чтобы отделить новый блок кода.
Для создания отступов используй клавишу Tab.
@error_too_much_indentation = Слишком большой отступ.
Отступы должны быть одинаковыми для всех инструкций в блоке кода.
@error_not_a_statement = Недопустимая инструкция.
@error_not_a_statement2 = Недопустимая инструкция. Ты имеешь в виду {0}?
@error_invalid_expression = Недопустимое выражение.
@error_new_line_expected = Ожидается новая строка.
@error_unexpected_token = Ожидается {0}.
@error_missing_colon = В начале каждого блока кода должно стоять двоеточие `:`.
@error_unexpected_assign = Здесь нельзя выполнить присваивание. Для проверки значений на равенство используй `==`.
@error_invalid_for_syntax = Недопустимый цикл `for`. Цикл `for` выглядит так:
`for n in range(3):`
За `for` всегда следует переменная цикла, `in`, а затем последовательность. В этом примере `n` — имя переменной, но его можно заменить любым другим именем.
@error_unknown_method = Такого метода не существует.
@error_bad_backslash = Обратную косую черту можно использовать для разделения выражений на несколько строк. После символа нужно добавить новую строку.
@error_mixed_indentation = Не смешивай табуляции и пробелы.
@error_expected_close_token = Ожидается запятая или закрывающая скобка.
@error_wrong_dict_literal = Ожидается `:` для разделения ключей и значений в словаре.
@error_assign_before_global = {0} присваивается до объявления глобальной переменной.
@error_wildcard_imports_not_allowed_in_function = Импорты вида `from x import *` не разрешены внутри функций.
@error_invalid_import = Нельзя импортировать файл с именем, являющимся недопустимым идентификатором. Допустимые идентификаторы могут содержать только буквы, цифры и знаки подчеркивания. Если имя файла содержит другие символы, его нужно переименовать.
@error_invalid_number_format = Недопустимый формат числа.
@error_compared_item_with_number = {0} — это не число, а предмет. Сравнивать его с числом бессмысленно.

Если ты хочешь проверить количество этого предмета, используй `num_items({0})`.
@error_compared_entity_with_number = {0} — это не число, а объект-сущность. Сравнивать его с числом бессмысленно.
@error_compared_unlock_with_number = {0} — это не число, а технология. Сравнивать ее с числом бессмысленно.

Если ты хочешь проверить, сколько раз ты ее разблокировал, используй `num_unlocked({0})`.
@error_nonsensical_or = Использование `or {0}` в условии бессмысленно, так как {0} — это константа.
Обрати внимание, что операторы сравнения вычисляются раньше `or`.

Пример:
`x == 5 or 6`
эквивалентно
`(x == 5) or 6`
Ненулевые числа считаются `True`, так что это выражение эквивалентно
`(x == 5) or True`
что всегда равно `True`.

Теоретически это допустимый код на Python, но так писать не стоит.
@error_item_condition = {0} — это предмет, а не логическое значение. Использовать его как самостоятельное условие бессмысленно.
Возможно, ты хотел проверить, равно ли какое-то значение этому предмету?
`some_variable == {0}`
@error_unlock_condition = {0} — это технология, а не логическое значение. Использовать ее как самостоятельное условие бессмысленно.
Вот как можно проверить, разблокирована ли эта технология:
`num_unlocked({0}) > 0`
@error_entity_condition = {0} — это объект-сущность, а не логическое значение. Использовать его как самостоятельное условие бессмысленно.
Вот как можно проверить тип объекта-сущности под дроном:
`get_entity_type() == {0}`
@error_ground_condition = {0} — это тип земли, а не логическое значение. Использовать его как самостоятельное условие бессмысленно.
Вот как можно проверить тип земли под дроном:
`get_ground_type() == {0}`