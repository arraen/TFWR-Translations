@error_missing_default_parameter = Усі аргументи за замовчуванням повинні бути в кінці списку аргументів.
@error_invalid_name = {0} не є допустимим ім'ям. Імена повинні починатися з літери і можуть містити лише літери, цифри та знаки підкреслення. Воно також не може бути зарезервованим ключовим словом.
@error_reserved_keyword = {0} є зарезервованим ключовим словом. Ви не можете використовувати його як ім'я.
@error_invalid_assign_expr = Неможливо присвоїти значення цьому виразу
@error_no_statements = Блок коду повинен містити принаймні одну інструкцію.
Statement може бути викликом функції, наприклад `harvest()`, або присвоєнням змінної.
Якщо ви нічого не хочете робити в блоці коду, використовуйте statement `pass`.
@error_not_enough_indentation = Тут недостатньо відступу.
Після : має бути більший відступ, ніж перед ним, щоб відокремити новий блок коду.
Використовуйте клавішу Tab для відступу коду.
@error_too_much_indentation = Тут забагато відступу.
Відступ має бути однаковим для всіх statements всередині одного блоку коду.
@error_not_a_statement = Це не є дійсним statement.
@error_not_a_statement2 = Це не є дійсним statement. Ви мали на увазі написати {0} ?
@error_invalid_expression = Це не є дійсним виразом.
@error_new_line_expected = Тут очікується новий рядок.
@error_unexpected_token = Тут очікується {0}.
@error_missing_colon = На початку кожного блоку коду має бути двокрапка `:`.
@error_unexpected_assign = Ви не можете робити присвоєння тут. Щоб перевірити на рівність, використовуйте `==`.
@error_invalid_for_syntax = Це не є дійсним циклом for. Цикл for виглядає так:
`for n in range(3):`
Після `for` завжди йде змінна циклу, потім `in`, а потім послідовність. У цьому прикладі `n` — це ім'я змінної, але його можна замінити будь-яким іншим іменем.
@error_unknown_method = Цього методу не існує.
@error_bad_backslash = Зворотну скісну риску можна використовувати для розбиття виразів на кілька рядків. Але після неї потрібно додати новий рядок.
@error_mixed_indentation = Не можна змішувати табуляцію та пробіли.
@error_expected_close_token = Очікувалася кома або закриваюча дужка.
@error_wrong_dict_literal = Очікувалася :, щоб розділити ключі та значення словника.
@error_assign_before_global = {0} присвоєно до оголошення global.
@error_wildcard_imports_not_allowed_in_function = Імпорти форми `from x import *` не дозволені всередині функцій.
@error_invalid_import = Ви не можете імпортувати файли з іменами, які не є дійсними ідентифікаторами. Дійсні ідентифікатори можуть містити лише літери, цифри та знаки підкреслення. Якщо ім'я вашого файлу містить інші символи, ви повинні перейменувати його.
@error_invalid_number_format = Цей формат числа не є дійсним.
@error_compared_item_with_number = {0} не є числом, це предмет. Порівнювати його з числом не має сенсу.

Якщо ви хочете перевірити, скільки цього предмету у вас є, використовуйте `num_items(`{0}`)` натомість.
@error_compared_entity_with_number = {0} не є числом, це об'єкт. Порівнювати його з числом не має сенсу.
@error_compared_unlock_with_number = {0} не є числом, це розблокування. Порівнювати його з числом не має сенсу.

Якщо ви хочете перевірити, скільки разів ви розблокували це, використовуйте `num_unlocked(`{0}`)` натомість.
@error_nonsensical_or = Використання `or `{0} в умові не має сенсу, оскільки {0} є константою.
Зауважте, що оператори порівняння оцінюються перед `or`.

Приклад:
`x == 5 or 6`
еквівалентно
`(x == 5) or 6`
Ненульові числа вважаються істинними, тому це еквівалентно
`(x == 5) or True`
що завжди є true.

Це теоретично дійсний код Python, але немає жодної причини коли-небудь писати його таким чином.
@error_item_condition = {0} є предметом, а не булевим значенням. Використання його як умови само по собі не має сенсу.
Можливо, ви хотіли перевірити, чи дорівнює значення цьому предмету?
`some_variable == `{0}
@error_unlock_condition = {0} є розблокуванням, а не булевим значенням. Використання його як умови само по собі не має сенсу.
Ось як ви можете перевірити, чи unlock розблоковано:
`num_unlocked(`{0}`) > 0`
@error_entity_condition = {0} є об'єктом, а не булевим значенням. Використання його як умови само по собі не має сенсу.
Ось як ви можете перевірити тип об'єкту під дроном:
`get_entity_type() == `{0}
@error_ground_condition = {0} є типом землі, а не булевим значенням. Використання його як умови само по собі не має сенсу.
Ось як ви можете перевірити тип землі під дроном:
`get_ground_type() == `{0}
