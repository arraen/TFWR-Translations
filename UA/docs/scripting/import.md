# Імпорт
Розміщення всього коду в одному файлі швидко стає некерованим.
Statements `import` дозволяють імпортувати функції та глобальні змінні з іншого файлу.
Як це працює на одному скріншоті:
![](ImportsInOnePicture400)

Тут `import module2` запускає файл під назвою `module2` і дає вам доступ до всіх його globals.
Потім ви можете отримати доступ до змінних і функцій в імпортованому модулі, використовуючи оператор `.`.
Отже, у цьому прикладі `module2.print_x()` викликає `print_x()` у `module2`.

### Немає потреби читати далі

Ви також можете перемістити globals з імпортованого модуля в поточний scope, де виконується statement `import`, використовуючи синтаксис `from`.

`from module2 import print_x
print_x()`
Імпортує лише вказані globals з `module2`.

або

`from module2 import *
print_x()`
Імпортує всі globals з `module2`.

Це також імпортує файл `module2`, але замість доступу до нього через змінну під назвою `module2`, воно розпаковує globals з `module2` і присвоює їх безпосередньо в локальний scope.

Ця форма імпорту зазвичай не рекомендується, оскільки вона погано працює, коли два файли імпортують один одного, і ви можете випадково перезаписати змінні у файлі імпорту через конфлікт імен. Безпечніше уникати синтаксису `from`, якщо ви не впевнені, що робите.

# Як це працює насправді

## TLDR
Імпорти можуть бути досить неінтуїтивними, але більшості проблем можна уникнути, дотримуючись синтаксису `import file` замість `from file import`, і загортаючи все, що не є глобальним визначенням, у
`if __name__ == "__main__":`

## Побічні ефекти імпорту
Коли ви вперше імпортуєте файл, він виконає весь файл, а потім дасть вам доступ до всіх змінних, які були визначені під час виконання.
Якщо ви імпортуєте той самий файл знову, він просто поверне кешований модуль з першого разу.

Це означає, що statements `import` можуть мати побічні ефекти. Якщо ви імпортуєте файл, який викликає `harvest()`, він насправді збере врожай під час імпорту. Але коли ви імпортуєте його знову, він не збере врожай знову, оскільки файл запускається лише один раз.

Існує спосіб уникнути таких побічних ефектів за допомогою змінної `__name__`. Це змінна, яка автоматично встановлюється на `"__main__"`, коли файл запускається безпосередньо, і на ім'я файлу, коли файл запускається через `import`.
Вважається хорошою практикою поміщати будь-який код, який ви не хочете запускати під час імпорту файлу, всередину блоку `if __name__ == "__main__":`.

Поширеною структурою файлів у Python є розміщення коду, який має виконуватися під час запуску файлу, у функцію `main()`. Таким чином ви маєте чітке розмежування між локальними змінними (визначеними всередині `main()`) і глобальними змінними, які можна імпортувати (визначеними поза `main()`).

`a_global_variable = "global"

def main():
    a_local_variable = "local"
    # do things

if __name__ == "__main__":
    main()`

## Цикли імпорту (Import Cycles)
Що станеться, якщо файл `a` імпортує файл `b`, а файл `b` імпортує файл `a`?

файл `a`:
`import b
x = 0`

файл `b`:
`import a
def f():
    print(a.x)`

Це працюватиме нормально. Припустімо, що жоден із двох файлів ще не завантажено, і хтось виконує `import a`.

- `a` виконується до рядка `import b`.
- `b` виконується до рядка `import a`.
- Модуль `a` вже існує, але не містить `x`, оскільки він дійшов лише до рядка `import b`.
- `b` зберігає посилання на наполовину завантажений модуль `a` у змінній під назвою `a`.
- `b` запускає statement `def` і зберігає функцію `f()`.
- `a` продовжує виконуватися та ініціалізує `x`.

Коли хтось викликає `b.f()`, він правильно надрукує `0`, оскільки модуль `a`, на який `b` має посилання, тепер повністю завантажений.

Тепер розглянемо той самий код із використанням синтаксису `from`.

файл `a`:
`from b import *
x = 0`

файл `b`:
`from a import *
def f():
    print(x)`

- `a` виконується до рядка `from b import *`.
- `b` виконується до рядка `from a import *`.
- Модуль `a` вже існує, але ще не був повністю виконаний.
- `b` розпаковує все, що зараз є в `a`, у свій власний global scope. На цьому етапі `a` нічого не містить, оскільки він ще не дійшов до рядка `x = 0`, тому нічого не імпортується.
- `b` запускає statement `def` і зберігає функцію `f()`.
- `a` продовжує виконуватися та ініціалізує `x`.

Якщо хтось зараз викличе `b.f()`, він отримає помилку, що `x` не існує в поточному scope. Це тому, що цього разу `b` не має посилання на `a`, що все ще завантажується, і не бачить визначень, які були додані після імпорту.
