# Лабіринти
`Items.Weird_Substance`, який отримується при [удобренні](docs/unlocks/fertilizer.md) рослин, має дивний вплив на кущі. Якщо дрон знаходиться над кущем, і ви викликаєте `use_item(Items.Weird_Substance, amount)`, кущ перетвориться на лабіринт із живоплоту.
Розмір лабіринту залежить від кількості використаного `Items.Weird_Substance` (другий аргумент виклику `use_item()`).
Без покращень лабіринту використання `n` `Items.Weird_Substance` призведе до створення лабіринту `n`x`n`. Кожен рівень покращення лабіринту подвоює скарб, але також подвоює необхідну кількість `Items.Weird_Substance`.
Отже, щоб створити лабіринт на все поле:

`plant(Entities.Bush)
substance = get_world_size() * 2**(num_unlocked(Unlocks.Mazes) - 1)
use_item(Items.Weird_Substance, substance)`


Чомусь дрон не може пролітати над живоплотом, хоча він не виглядає таким вже й високим.

Десь у живоплоті захований скарб. Використовуйте `harvest()` на скарбі, щоб отримати золото, що дорівнює площі лабіринту. (Наприклад, лабіринт 5x5 дасть 25 золота.)

Якщо ви використаєте `harvest()` десь-інде, лабіринт просто зникне.

`get_entity_type()` дорівнює `Entities.Treasure`, якщо дрон знаходиться над скарбом, і `Entities.Hedge` скрізь в інших місцях лабіринту.

Лабіринти не містять жодних петель, якщо ви не використовуєте лабіринт повторно (див. нижче, як повторно використовувати лабіринт). Тому дрон не може опинитися в тій самій позиції знову, не повертаючись назад.

Ви можете перевірити наявність стіни, спробувавши пройти крізь неї.
`move()` повертає `True`, якщо це вдалося, і `False` в іншому випадку.

`can_move()` можна використовувати, щоб перевірити наявність стіни без руху.

Якщо ви не знаєте, як дістатися до скарбу, погляньте на Підказку 1. Вона показує, як підійти до подібної проблеми.

Використання `measure()` будь-де в лабіринті повертає позицію скарбу.
`x, y = measure()`

Для додаткового виклику ви також можете повторно використовувати лабіринт, знову використовуючи таку ж кількість `Items.Weird_Substance` на скарбі.
Це збере скарб і створить новий скарб у випадковому місці лабіринту.

Щоразу, коли скарб переміщується, деякі стіни лабіринту можуть бути випадковим чином видалені. Тому повторно використані лабіринти можуть містити петлі.

Зауважте, що петлі в лабіринті роблять його набагато складнішим, оскільки це означає, що ви можете потрапити в те саме місце знову, не повертаючись назад.
Повторне використання лабіринту не дає вам більше золота, ніж просто збір і створення нового лабіринту.
Це на 100% додатковий виклик, який ви можете просто пропустити.
Це варто робити лише в тому випадку, якщо додаткова інформація та короткі шляхи допоможуть вам вирішити лабіринт швидше.

Скарб можна переміщувати до 300 разів. Після цього використання дивної cубстанції на скарбі більше не збільшуватиме золото в ньому, і він більше не рухатиметься.

<spoiler=show hint 1>Ось загальний підхід до вирішення проблеми:

Створіть лабіринт і уявіть, що ви дрон.

Подумайте, як би ви намагалися знайти скарб, якби були в лабіринті.

Запишіть свою стратегію крок за кроком, щоб хтось інший міг слідувати їй, не думаючи.

Тепер спробуйте перекласти ваші кроки в код.
</spoiler>
<spoiler=show hint 2>Поки немає петель: Усі стіни — це насправді просто одна велика з'єднана стіна. Якщо ви будете слідувати за стіною, вона проведе вас через весь лабіринт.
Цей підхід вимагає дуже мало коду, і вам не потрібно відстежувати, де ви вже були. Близько 10 рядків коду — це все, що вам потрібно.</spoiler>
<spoiler=show hint 3>Замість того, щоб переміщувати дрон в абсолютних напрямках, таких як схід або захід, може бути дуже корисно переміщувати дрон у відносних напрямках, таких як "повернути праворуч" або "повернути ліворуч". Для цього вам потрібно відстежувати, в якому напрямку зараз рухається дрон. Дрон насправді ніколи не обертається, але ви все одно можете зберігати "віртуальне" обертання в коді.
Наступний трюк з індексом корисний для цього:

`directions = [North, East, South, West]
index = 0`

Використовуйте `% 4`, щоб дозволити йому обертатися "по колу", так що після `West` він повертається до `North`.
`# повернути праворуч
index = (index + 1) % 4`

`# повернути ліворуч
index = (index - 1) % 4

move(directions[index])`</spoiler>
<spoiler=show hint 4>Якщо ви не можете вирішити це, ви завжди можете полегшити собі життя і зробити це менш ефективно.
Вирішення лабіринту `1`x`1` є тривіальним.</spoiler>
