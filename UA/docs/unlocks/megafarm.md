# Mega Farm (Мегаферма)
Це неймовірно потужне розблокування дає вам доступ до кількох дронів.

Як і раніше, ви починаєте лише з одним дроном. Додаткові дрони спочатку повинні бути створені (spawned) і зникнуть після завершення програми.
Кожен дрон виконує власну окрему програму. Нові дрони можна створити за допомогою функції `spawn_drone(function)`.

`def drone_function():
    move(North)
    do_a_flip()

spawn_drone(drone_function)`

Це створює (spawns) новий дрон у тій самій позиції, що й дрон, який запустив команду `spawn_drone(function)`. Новий дрон потім починає виконувати вказану функцію. Коли він закінчить, він зникне автоматично.

Дрони не стикаються один з одним.

Використовуйте `max_drones()`, щоб отримати максимальну кількість дронів, які можуть існувати одночасно.
Використовуйте `num_drones()`, щоб отримати кількість дронів, які вже є на фермі.


## Приклад:
`def harvest_column():
    for _ in range(get_world_size()):
        harvest()
        move(North)

while True:
    if spawn_drone(harvest_column):
        move(East)`

Це змусить ваш перший дрон рухатися горизонтально і створювати більше дронів. Створені дрони потім будуть рухатися вертикально і збирати все на своєму шляху.

Якщо всі доступні дрони вже створені, `spawn_drone()` нічого не зробить і поверне `None`.

Ось ще один приклад, який передає різний напрямок кожному дрону.
`for dir in [North, East, South, West]:
    def task():
        move(dir)
        do_a_flip()
    spawn_drone(task)`

## Усі дрони рівні
Немає спеціального "головного" дрона. Усі дрони можуть створювати інші дрони, і всі вони враховуються в ліміт дронів. Усі дрони зникають, коли вони завершують роботу. Якщо перший дрон закінчує свою програму раніше, інший дрон стане тим, чиє виконання візуалізується підсвічуванням коду. Усі дрони можуть викликати breakpoints, і коли дрон викликає breakpoint, підсвічування коду перемикається на цього дрона.

<spoiler=show hint> Ознайомтеся з цією суперкорисною паралельною функцією `for_all`, яка приймає будь-яку функцію і запускає її на кожній клітинці ферми. Вона використовує всі доступні дрони для цього.

`def for_all(f):
	def row():
		for _ in range(get_world_size()-1):
			f()
			move(East)
		f()
	for _ in range(get_world_size()):
		if not spawn_drone(row):
			row()
		move(North)

for_all(harvest)`

Один особливо корисний шаблон — створити дрон, якщо він доступний, інакше зробити це самостійно.

`if not spawn_drone(task):
	task()`
</spoiler>

## Очікування іншого дрона
Використовуйте функцію `wait_for(drone)`, щоб чекати завершення роботи іншого дрона. Ви отримуєте handle `drone`, коли створюєте дрон.
`wait_for(drone)` повертає значення (return value) функції, яку виконував інший дрон.

`def get_entity_type_in_direction(dir):
    move(dir)
    return get_entity_type()

def zero_arg_wrapper():
    return get_entity_type_in_direction(North)
drone = spawn_drone(zero_arg_wrapper)
print(wait_for(drone))`

Зауважте, що створення дронів займає час, тому не варто створювати новий дрон для кожної дрібниці.

Ви можете використовувати `has_finished(drone)`, щоб перевірити, чи завершив дрон роботу, не чекаючи його.

## Немає спільної пам'яті (No Shared Memory)
Кожен дрон має власну пам'ять і не може безпосередньо читати або писати глобальні змінні (globals) іншого дрона.

`x = 0

def increment():
    global x
    x += 1

wait_for(spawn_drone(increment))
print(x)`

Це надрукує `0`, тому що новий дрон збільшив свою власну копію глобальної `x`, що не впливає на `x` першого дрона.

## Стан гонитви (Race Conditions)
Кілька дронів можуть взаємодіяти з однією і тією ж клітинкою ферми одночасно. Якщо два дрони взаємодіють з однією клітинкою протягом одного тіку, відбудуться обидві взаємодії, але результати можуть відрізнятися залежно від порядку взаємодій.

Наприклад, уявіть, що дрони `0` і `1` знаходяться над одним деревом, яке майже повністю виросло.
Дрон `0` викликає
`use_item(Items.Fertilizer)`
Дрон `1` викликає
`harvest()`

Якщо ці дії відбуваються одночасно, дерево спочатку буде удобрено, а потім зібрано. У такому випадку ви отримаєте з нього дерево (wood). Однак, якщо Дрон `1` трохи швидший, дерево буде зібрано до того, як воно буде удобрено, і ви не отримаєте дерево.
Це називається "стан гонитви" (race condition). Це поширена проблема в паралельному програмуванні, де результат залежить від порядку виконання операцій.

Ось ще одна проблемна ситуація, яка може статися, коли кілька дронів запускають однаковий код одночасно в одній позиції.
`if get_water() < 0.5:
    use_item(Items.Water)`

Якщо кілька дронів запускають це одночасно, вони всі виконають перший рядок, що перемістить їх у блок `if`. Потім вони всі використають воду, марнуючи багато води.
На той час, коли дрон досягне другого рядка, `get_water()` може вже не бути менше `0.5`, оскільки інший дрон тим часом полив клітинку.
