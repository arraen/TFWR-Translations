# Name Scopes (Області видимості імен)
Scopes визначають, до яких змінних і звідки можна отримати доступ. Scope — це по суті відображення імен у значення.
Вони працюють так само, як і в Python.

Існує глобальна область видимості (global scope), і кожна функція має локальну область видимості (local scope).
Коли ви визначаєте змінну, вона додається до поточної області видимості.
Усе, що знаходиться за межами визначення функції, вважається частиною global scope.

`x = 1`
Присвоює значення `1` імені `x` у global scope.

Цей statement `def` присвоює функцію імені `f` у global scope.
`def f():
    `Присвоює значення `1` імені `y` у local scope функції `f`.`
    y = 1

    `Присвоює функцію імені `g` у local scope функції `f`.`
    def g():
        pass`

`f()`
Отримує функцію, збережену в `f`, з global scope і викликає її.

`print(y)`
Цей statement print у global scope видає помилку, оскільки `y` ніколи не була оголошена в global scope, тому ми не можемо її тут прочитати.
Вона існувала лише в local scope функції `f`.

## Ключове слово global
За замовчуванням усі змінні у функціях прив'язуються до local scope, навіть якщо змінна з таким самим ім'ям існує в global scope.

`x = 0

def f():
    x = 1
f()
print(x)`

Цей код друкує `0`, тому що локальна `x` всередині `f` — це не та сама змінна, що й глобальна `x`, тому глобальна `x` залишається незмінною. Це важливо, оскільки інакше виклик функції міг би випадково перезаписати глобальну змінну, яка просто має те саме ім'я, що й локальна змінна цієї функції.

Якщо ви хочете записати дані в глобальну змінну, ви повинні зробити це явно, використовуючи ключове слово `global`.

`x = 0

def f():
    global x
    x = 1
f()
print(x)`

У цьому прикладі `global x` прив'язує `x` до глобальної змінної `x`, визначеної вище. Тепер це надрукує `1`.
Зауважте, що зміна глобальних змінних зазвичай є першим кроком до спагетті-коду (spaghetti code), де кожна частина програми впливає на кожну іншу частину програми, тому не зловживайте цим.

## Цикли та розгалуження (Loops and branches)
Цикли та розгалуження не створюють власних областей видимості (scopes), тому все, що оголошено всередині них, все одно можна використовувати ззовні.

`for i in range(3):
    pass
print(i)`

Це надрукує `2`, оскільки остання ітерація циклу `for` присвоїла `2` змінній `i`.
